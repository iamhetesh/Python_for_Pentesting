from flask import Flask, render_template, request
import pandas as pd
import numpy as np
from keras import regularizers
from sklearn.model_selection import train_test_split
from keras.callbacks import LambdaCallback
from keras.models import Sequential
from keras.optimizers import SGD
from sklearn.ensemble import RandomForestClassifier
from keras.layers import Dense, Dropout
from sklearn.preprocessing import LabelEncoder, StandardScaler
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.metrics import confusion_matrix
from sklearn.neural_network import MLPClassifier

app = Flask(__name__, template_folder="/path/to/dir")

@app.route('/')
def index():
    return render_template('index')

@app.route('/predict', methods=['POST'])
def predict():
    global X_test
    global new_x
    global model
    global names
    file = request.files["dataset"]
    data = pd.read_csv(file, sep='|') # The dataset should have '57' columns with different sample attributes and characteristics 
    x = data.drop(['columns'], axis=1).values # Dropping unnecessary columns from the dataset
    y = data['malware or legitimate column'].values # It is used to train the neural network to learn whether the given file is benign or malicious based on its features.
    names = data['Name'].values
    new_x = LabelEncoder().fit_transform(x.ravel()).reshape(*x.shape)
    new_y = LabelEncoder().fit_transform(y)
    reshaped_x = new_x.reshape((new_x.shape[0], -1))
    norm_x = StandardScaler().fit_transform(reshaped_x)
    X_train, X_test, y_train, y_test = train_test_split(norm_x, new_y, test_size=0.2, random_state=42)

    model = Sequential()
    model.add(Dense(256, input_dim=x.shape[1], activation='relu'))
    model.add(Dense(128, activation='relu'))
    model.add(Dense(64, activation='relu'))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(16, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    sgd = SGD(learning_rate = 0.001, momentum = 0.9)
    model.compile(loss='binary_crossentropy', optimizer=sgd, metrics=['accuracy'])  

    early_stopping = EarlyStopping(monitor='val_accuracy', patience=15, verbose=1)
    checkpointer = ModelCheckpoint(filepath='best_weights.h5', verbose=1, save_best_only=True)

    epoch_history = []
    epoch_callback = LambdaCallback(
        on_epoch_end=lambda epoch, logs: epoch_history.append(logs))

    model.fit(X_train, y_train, epochs=50, batch_size=32, callbacks=[early_stopping, checkpointer, epoch_callback], validation_data=(X_test, y_test))
    model.load_weights('save_the_weights_of_neural_network')

    score = model.evaluate(X_test, y_test, verbose=0)
    test_loss = score[0]
    test_accuracy = score[1]

    predictions = model.predict(X_test)

    rounded_predictions = np.round(predictions)

    cm = confusion_matrix(y_test, rounded_predictions)

    scaler = StandardScaler().fit(new_x)
    inv_norm_x = scaler.inverse_transform(X_test)

    malware_files = []
    legit_files = []
    for i in range(len(rounded_predictions)):
        if rounded_predictions[i] == 0:
            malware_files.append(inv_norm_x[i])
        else:
            legit_files.append(inv_norm_x[i])

    return render_template('predict', test_loss=test_loss, test_accuracy=test_accuracy, epoch_history=epoch_history, cm=cm)

@app.route('/group', methods=['POST'])
def group():
    predictions = model.predict(X_test)
    rounded_predictions = np.round(predictions)
    scaler = StandardScaler().fit(new_x)
    inv_norm_x = scaler.inverse_transform(X_test)

    malware_files = []
    legit_files = []
    for i in range(len(rounded_predictions)):
        if rounded_predictions[i] == 0:
            malware_files.append(names[i])
        else:
            legit_files.append(names[i])

    return render_template('group', malware_files=malware_files, legit_files=legit_files)


if __name__ == "__main__":
    app.run(debug=True)
